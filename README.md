### 配置相关
[git SSH 配置](https://github.com/zhoujin4515/Blog/issues/1)

### 为什么需要加密
http协议是使用明文传输的，如果在传输链路上被拦截，会造成信息泄露，这就是`中间人攻击`；
### 对称加密
通信双方拥有同一个密钥，可以通过这个密钥进行加密解密（MD5就是使用的对称加密）；

为什么对称加密不适合?
服务器如何安全的把密钥发送给客户端？没有办法！除非浏览器预存了所有https网站服务的密钥，这个不现实，所以需要非对称加密

### 非对称加密
一个公钥，一个私钥，公钥加密的数据需要用私钥解密，私钥加密的数据需要用公钥解密；
如何使用非对称加密实现安全连接？
1.客户端拥有公钥X，私钥X^, 服务端拥有公钥Y，私钥Y^。
2.客户端把公钥X发送给服务端，服务端使用公钥X加密数据后发送给客户端，客户端拥有X^私钥解密服务端返回的数据。
3.服务端吧公钥Y发送给客户端，客户端使用公钥Y加密数据后发送给服务端，服务端拥有Y^私钥解密客户端发送的数据。
4.因为私钥是安全且不被明文传输，所以这种方式是较为安全的。
5.由于非对称加密比较耗费性能，而对称加密要快的多。
6.不过这种方式还是有漏洞，中间人攻击还是可以欺骗客户端及服务端。

### 非对称加密 + 对称加密
可以使用 非对称加密 来 加密 对称加密中的 密钥。保证密钥不被第三方知晓，然后使用对称加密来传输数据。
1.服务端拥有公钥Y，私钥Y^.
2.服务端将公钥Y明文发送给客户端。
3.客户端随机生成一个用与对称加密的密钥X，使用公钥Y加密后发送给服务端。
4.服务端使用私钥Y^解密后得到密钥X，这样双方都拥有了密钥X，且密钥X不被外部知晓。
5.这种方式节省性能，非对称加密解密均只是执行了一次，但是还是有漏洞，中间人攻击还是可以欺骗客户端及服务端。

### 中间人攻击
中间人攻击是指在数据传输链路上被劫持，数据被修改，且通信双方不知道数据被修改了
1.服务端拥有公钥Y，私钥Y^.
2.服务端将公钥Y明文发送给客户端。
3.中间人劫持到公钥Y，保存下来，且中间人拥有自己的公钥B，私钥B^，中间人将公钥B发送给客户端。
4.客户端使用公钥B加密随机生成的对称加密的密钥X，发送给服务器（浏览器无法得知公钥被替换了）。
5.中间人劫持后，使用私钥B^解密出来密钥X，然后用服务端的公钥Y加密后发送到服务器。
6.这样中间人就代理成了客户端了，能破解所有传输的数据了。

### 数字证书
浏览器如何校验接收到的公钥是正确网站的公钥？
CA机构就是发放安全域名的中央，是值得信赖的，由它给网站发放唯一的”身份证“，这个”身份证“就是**数字证书**。
使用数字证书来保证明文传输的公钥是没有被污染的
1.数字证书拥有持有者的信息以及公钥。
2.客户端向CA机构获取该网站服务的数字证书，包含了持有者的信息及公钥，校验是否正确。
3.如果校验通过，则使用公钥加密随机生成的密钥X，发送到服务端，进行对称加密数据传输。

为什么数字证书能保证公钥是没有被污染的？
数字签名的制作过程：
1.CA机构拥有公钥及私钥
2.CA机构对数字证书明文数据T进行hash
3.CA机构对hash后的值用私钥加密，得到数字签名S
明文和数字签名组成了数字证书，这样一份数字证书就可以颁发给网站了

浏览器的验证过程：
1.浏览器拿到证书，得到明文T，以及数字签名S
2.拿到公钥，对数字签名S进行解密，得到明文T进行hash后的数据S^
3.拿到明文中的hash算法，对明文T进行hash,得到T^
4.即 S^ ===  T^ 则验证通过


### 函数声明 vs 函数表达式
1.函数是值，它可以在代码任何地方被分配，赋值或声明
2.如果函数被声明为单独的语句，则是一个函数声明
3.如果函数是作为表达式的一部分创建的，则是一个函数表达式
4.函数声明会在引擎初始化代码时被寻找且创建这些函数
```javascript
console.log(a) // ƒ a() { console.log('caonima')}
function a() {
    console.log('caonima')
}
```
5.函数表达式在执行流程到达时创建

# 垃圾回收
垃圾回收是自动完成的，我们不能强制执行或是阻止执行。
当对象是可达状态时，它一定是存在于内存中的。
被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达。

# 对象的引用和复制
对象通过引用被赋值和拷贝。换句话说，一个变量存储的不是“对象的值”，而是一个对值的“引用”（内存地址）。因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。

所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一个对象上。

为了创建“真正的拷贝”（一个克隆），我们可以使用 Object.assign 来做所谓的“浅拷贝”（嵌套对象被通过引用进行拷贝）或者使用“深拷贝”函数，例如 _.cloneDeep(obj)。

# 对象方法和this
- 存储在对象属性中的函数被称为“方法”。
- 方法允许对象进行像 object.doSomething() 这样的“操作”。
- 方法可以将对象引用为 this。

this 的值是在程序运行时得到的。
- 一个函数在声明时，可能就使用了 this，但是这个 this 只有在函数被调用时才会有值。
- 可以在对象之间复制函数。
- 以“方法”的语法调用函数时：object.method()，调用过程中的 this 值是 object。
请注意箭头函数有些特别：它们没有 this。在箭头函数内部访问到的 this 都是从外部获取的。

# 构造器和操作符new
- 构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。
- 构造函数只能使用 new 来调用。这样的调用意味着在开始时创建了空的 this，并在最后返回填充了值的 this。

我们可以使用构造函数来创建多个类似的对象。
JavaScript 为许多内建的对象提供了构造函数：比如日期 Date、集合 Set 


